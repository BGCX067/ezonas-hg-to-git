<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html40/loose.dtd">
<html><!-- Created on December, 31 2009 by texi2html 1.66 --><!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

--><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>OGRE Manual v1.7 ('Cthugha'): Passes</title>

<meta name="description" content="OGRE Manual v1.7 ('Cthugha'): Passes">
<meta name="keywords" content="OGRE Manual v1.7 ('Cthugha'): Passes">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.66">
<style type="text/css">
body {font-family: Tahoma, Helvetica, sans-serif;}
h3, h2 {background: grey;}
</style>

</head>

<body alink="#FF0000" bgcolor="#FFFFFF" lang="en" link="#0000FF" text="#000000" vlink="#800080">

<a name="SEC39"></a>
<table border="0" cellpadding="1" cellspacing="1">
<tbody><tr><td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_15.html#SEC33"> &lt; </a>]</td>
<td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_17.html#SEC77"> &gt; </a>]</td>
<td align="LEFT" valign="MIDDLE"> &nbsp; </td><td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_13.html#SEC22"> &lt;&lt; </a>]</td>
<td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_14.html#SEC23"> Up </a>]</td>
<td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_45.html#SEC268"> &gt;&gt; </a>]</td>
<td align="LEFT" valign="MIDDLE"> &nbsp; </td><td align="LEFT" valign="MIDDLE"> &nbsp; </td><td align="LEFT" valign="MIDDLE"> &nbsp; </td><td align="LEFT" valign="MIDDLE"> &nbsp; </td><td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/index.html#SEC_Top">Top</a>]</td>
<td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_toc.html#SEC_Contents">Contents</a>]</td>
<td align="LEFT" valign="MIDDLE">[Index]</td>
<td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_abt.html#SEC_About"> ? </a>]</td>
</tr></tbody></table>
<hr size="1">
<h3> 3.1.2 Passes </h3>
<!--docid::SEC39::-->
A pass is a single render of the geometry in question; a single call to 
the rendering API with a certain set of rendering properties. A 
technique can have between one and 16 passes, although clearly the more 
passes you use, the more expensive the technique will be to render.<br><br>

To help clearly identify what each pass is used for, the pass can be 
named but its optional.  Passes not named within the script will take on
 a name that is the pass index number.  For example: the first pass in a
 technique is index 0 so its name would be "0" if it was not given a 
name in the script.  The pass name must be unique within the technique 
or else the final pass is the resulting merge of all passes with the 
same name in the technique.  A warning message is posted in the Ogre.log
 if this occurs.  Named passes can help when inheriting a material and 
modifying an existing pass: (See section <a href="http://www.ogre3d.org/docs/manual/manual_25.html#SEC139">3.1.11 Script Inheritence</a>)<br><br>

Passes have a set of global attributes (described below), zero or more nested texture_unit entries (See section <a href="http://www.ogre3d.org/docs/manual/manual_17.html#SEC77">3.1.3 Texture Units</a>), and optionally a reference to a vertex and / or a fragment program (See section <a href="http://www.ogre3d.org/docs/manual/manual_23.html#SEC125">3.1.9 Using Vertex/Geometry/Fragment Programs in a Pass</a>).

<br><br>
Here are the attributes you can use in a 'pass' section of a .material script:

<ul>
<li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC41">ambient</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC42">diffuse</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC43">specular</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC44">emissive</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC45">scene_blend</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC46">separate_scene_blend</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC47">scene_blend_op</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC48">separate_scene_blend_op</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC49">depth_check</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC50">depth_write</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC51">depth_func</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC52">depth_bias</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC53">iteration_depth_bias</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC54">alpha_rejection</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC55">alpha_to_coverage</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC56">light_scissor</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC57">light_clip_planes</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC58">illumination_stage</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC60">transparent_sorting</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC59">normalise_normals</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC61">cull_hardware</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC62">cull_software</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC63">lighting</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC64">shading</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC65">polygon_mode</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC66">polygon_mode_overrideable</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC67">fog_override</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC68">colour_write</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC70">max_lights</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC69">start_light</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC71">iteration</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC72">point_size</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC73">point_sprites</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC74">point_size_attenuation</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC75">point_size_min</a>
</li><li>
<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC76">point_size_max</a>
</li></ul>

<a name="SEC40"></a>
<h2> Attribute Descriptions </h2>
<!--docid::SEC40::-->
<a name="ambient"></a>
<a name="SEC41"></a>
<h3> ambient </h3>
<!--docid::SEC41::-->

Sets the ambient colour reflectance properties of this pass. <strong>This
 attribute has no effect if a asm, CG, or HLSL shader program is used.  
With GLSL, the shader can read the OpenGL material state.</strong> <br><br>

Format: ambient (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour)<br>
NB valid colour values are between 0.0 and 1.0.<br><br>

Example: ambient 0.0 0.8 0.0<br><br>

The base colour of a pass is determined by how much red, green and blue 
light is reflects at each vertex. This property determines how much 
ambient light (directionless global light) is reflected. 
It is also possible to make the ambient reflectance track the vertex 
colour as defined in the mesh by using the keyword vertexcolour instead 
of the colour values.
The default is full white, meaning objects are completely globally 
illuminated. Reduce this if you want to see diffuse or specular light 
effects, or change the blend of colours to make the object have a base 
colour other than white. This setting has no effect if dynamic lighting 
is disabled using the 'lighting off' attribute, or if any texture layer 
has a 'colour_op replace' attribute.<br><br>

Default: ambient 1.0 1.0 1.0 1.0<br><br>

<a name="diffuse"></a>
<a name="SEC42"></a>
<h3> diffuse </h3>
<!--docid::SEC42::-->

Sets the diffuse colour reflectance properties of this pass. <strong>This
 attribute has no effect if a asm, CG, or HLSL shader program is used.  
With GLSL, the shader can read the OpenGL material state.</strong><br><br>

Format: diffuse (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour)<br>
NB valid colour values are between 0.0 and 1.0.<br><br>

Example: diffuse 1.0 0.5 0.5<br><br>

The base colour of a pass is determined by how much red, green and blue 
light is reflects at each vertex. This property determines how much 
diffuse light (light from instances of the Light class in the scene) is 
reflected. 
It is also possible to make the diffuse reflectance track the vertex 
colour as defined in the mesh by using the keyword vertexcolour instead 
of the colour values.
The default is full white, meaning objects reflect the maximum white 
light they can from Light objects. This setting has no effect if dynamic
 lighting is disabled using the 'lighting off' attribute, or if any 
texture layer has a 'colour_op replace' attribute.<br><br>

Default: diffuse 1.0 1.0 1.0 1.0<br><br>

<a name="specular"></a>
<a name="SEC43"></a>
<h3> specular </h3>
<!--docid::SEC43::-->

Sets the specular colour reflectance properties of this pass. <strong>This
 attribute has no effect if a asm, CG, or HLSL shader program is used.  
With GLSL, the shader can read the OpenGL material state.</strong><br><br>

Format: specular (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour) &lt;shininess&gt;<br>
NB valid colour values are between 0.0 and 1.0. Shininess can be any value greater than 0.<br><br>

Example: specular 1.0 1.0 1.0 12.5<br><br>

The base colour of a pass is determined by how much red, green and blue 
light is reflects at each vertex. This property determines how much 
specular light (highlights from instances of the Light class in the 
scene) is reflected. 
It is also possible to make the diffuse reflectance track the vertex 
colour as defined in the mesh by using the keyword vertexcolour instead 
of the colour values.
The default is to reflect no specular light. The colour of the specular 
highlights is determined by the colour parameters, and the size of the 
highlights by the separate shininess parameter.. The higher the value of
 the shininess parameter, the sharper the highlight ie the radius is 
smaller.  Beware of using shininess values in the range of 0 to 1 since 
this causes the the specular colour to be applied to the whole surface 
that has the material applied to it.  When the viewing angle to the 
surface changes, ugly flickering will also occur when shininess is in 
the range of 0 to 1.  Shininess values between 1 and 128 work best in 
both DirectX and OpenGL renderers.  This setting has no effect if 
dynamic lighting is disabled using the 'lighting off' attribute, or if 
any texture layer has a 'colour_op replace' attribute.<br><br>

Default: specular 0.0 0.0 0.0 0.0 0.0<br><br>

<a name="emissive"></a>
<a name="SEC44"></a>
<h3> emissive </h3>
<!--docid::SEC44::-->

Sets the amount of self-illumination an object has. <strong>This 
attribute has no effect if a asm, CG, or HLSL shader program is used.  
With GLSL, the shader can read the OpenGL material state.</strong><br><br>

Format: emissive (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour)<br>
NB valid colour values are between 0.0 and 1.0.<br><br>

Example: emissive 1.0 0.0 0.0<br><br>

If an object is self-illuminating, it does not need external sources to 
light it, ambient or otherwise. It's like the object has it's own 
personal ambient light. Unlike the name suggests, this object doesn't 
act as a light source for other objects in the scene (if you want it to,
 you have to create a light which is centered on the object). 
It is also possible to make the emissive colour track the vertex colour 
as defined in the mesh by using the keyword vertexcolour instead of the 
colour values.
This setting has no effect if dynamic lighting is disabled using the 
'lighting off' attribute, or if any texture layer has a 'colour_op 
replace' attribute.<br><br>

Default: emissive 0.0 0.0 0.0 0.0<br><br>

<a name="scene_blend"></a>
<a name="SEC45"></a>
<h3> scene_blend </h3>
<!--docid::SEC45::-->

Sets the kind of blending this pass has with the existing contents of 
the scene. Wheras the texture blending operations seen in the 
texture_unit entries are concerned with blending between texture layers,
 this blending is about combining the output of this pass as a whole 
with the existing contents of the rendering target. This blending 
therefore allows object transparency and other special effects. There 
are 2 formats, one using predefined blend types, the other allowing a 
roll-your-own approach using source and destination factors.<br><br>

Format1: scene_blend &lt;add|modulate|alpha_blend|colour_blend&gt;<br><br>

Example: scene_blend add<br><br>

This is the simpler form, where the most commonly used blending modes 
are enumerated using a single parameter. Valid &lt;blend_type&gt; 
parameters are:
<dl compact="compact">
<dt>add
</dt><dd>The colour of the rendering output is added to the scene. Good 
for explosions, flares, lights, ghosts etc. Equivalent to 'scene_blend 
one one'.
</dd><dt>modulate
</dt><dd>The colour of the rendering output is multiplied with the scene
 contents. Generally colours and darkens the scene, good for smoked 
glass, semi-transparent objects etc. Equivalent to 'scene_blend 
dest_colour zero'.
</dd><dt>colour_blend
</dt><dd>Colour the scene based on the brightness of the input colours, 
but don't darken. Equivalent to 'scene_blend src_colour 
one_minus_src_colour'
</dd><dt>alpha_blend
</dt><dd>The alpha value of the rendering output is used as a mask. Equivalent to 'scene_blend src_alpha one_minus_src_alpha'
</dd></dl>
<br>
Format2: scene_blend &lt;src_factor&gt; &lt;dest_factor&gt;<br><br>

Example: scene_blend one one_minus_dest_alpha<br><br>

This version of the method allows complete control over the blending 
operation, by specifying the source and destination blending factors. 
The resulting colour which is written to the rendering target is 
(texture * sourceFactor) + (scene_pixel * destFactor). Valid values for 
both parameters are:
<dl compact="compact">
<dt>one
</dt><dd>Constant value of 1.0
</dd><dt>zero
</dt><dd>Constant value of 0.0
</dd><dt>dest_colour
</dt><dd>The existing pixel colour
</dd><dt>src_colour
</dt><dd>The texture pixel (texel) colour
</dd><dt>one_minus_dest_colour
</dt><dd>1 - (dest_colour)
</dd><dt>one_minus_src_colour
</dt><dd>1 - (src_colour)
</dd><dt>dest_alpha
</dt><dd>The existing pixel alpha value
</dd><dt>src_alpha
</dt><dd>The texel alpha value
</dd><dt>one_minus_dest_alpha
</dt><dd>1 - (dest_alpha)
</dd><dt>one_minus_src_alpha
</dt><dd>1 - (src_alpha)
</dd></dl>
<br>
Default: scene_blend one zero (opaque)
<br><br>
Also see <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC46">separate_scene_blend</a>.

<a name="separate_scene_blend"></a>
<a name="SEC46"></a>
<h3> separate_scene_blend </h3>
<!--docid::SEC46::-->

This option operates in exactly the same way as <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC45">scene_blend</a>,
 except that it allows you to specify the operations to perform between 
the rendered pixel and the frame buffer separately for colour and alpha 
components. By nature this option is only useful when rendering to 
targets which have an alpha channel which you'll use for later 
processing, such as a render texture.<br><br>

Format1: separate_scene_blend &lt;simple_colour_blend&gt; &lt;simple_alpha_blend&gt;<br><br>

Example: separate_scene_blend add modulate<br><br>

This example would add colour components but multiply alpha components. The blend modes available are as in <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC45">scene_blend</a>. The more advanced form is also available:<br><br>

Format2: separate_scene_blend &lt;colour_src_factor&gt; 
&lt;colour_dest_factor&gt; &lt;alpha_src_factor&gt; 
&lt;alpha_dest_factor&gt;<br><br>

Example: separate_scene_blend one one_minus_dest_alpha one one <br><br>

Again the options available in the second format are the same as those in the second format of <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC45">scene_blend</a>.

<a name="scene_blend_op"></a>
<a name="SEC47"></a>
<h3> scene_blend_op </h3>
<!--docid::SEC47::-->

This directive changes the operation which is applied between the two components of the scene 
blending equation, which by default is 'add' (sourceFactor * source + destFactor * dest). You may 
change this to 'add', 'subtract', 'reverse_subtract', 'min' or 'max'.<br><br>

Format: scene_blend_op &lt;add|subtract|reverse_subtract|min|max&gt;<br><br>
Default: scene_blend_op add<br><br>

<a name="separate_scene_blend_op"></a>
<a name="SEC48"></a>
<h3> separate_scene_blend_op </h3>
<!--docid::SEC48::-->

This directive is as scene_blend_op, except that you can set the operation for colour and alpha
separately.

Format: separate_scene_blend_op &lt;colourOp&gt; &lt;alphaOp&gt;<br><br>
Default: separate_scene_blend_op add add<br><br>


<a name="depth_check"></a>
<a name="SEC49"></a>
<h3> depth_check </h3>
<!--docid::SEC49::-->

Sets whether or not this pass renders with depth-buffer checking on or not.<br><br>

Format: depth_check &lt;on|off&gt;<br><br>

If depth-buffer checking is on, whenever a pixel is about to be written 
to the frame buffer the depth buffer is checked to see if the pixel is 
in front of all other pixels written at that point. If not, the pixel is
 not written. If depth checking is off, pixels are written no matter 
what has been rendered before. Also see depth_func for more advanced 
depth check configuration.<br><br>

Default: depth_check on<br><br>

<a name="depth_write"></a>
<a name="SEC50"></a>
<h3> depth_write </h3>
<!--docid::SEC50::-->

Sets whether or not this pass renders with depth-buffer writing on or not.<br>

Format: depth_write &lt;on|off&gt;<br><br>

If depth-buffer writing is on, whenever a pixel is written to the frame 
buffer the depth buffer is updated with the depth value of that new 
pixel, thus affecting future rendering operations if future pixels are 
behind this one. If depth writing is off, pixels are written without 
updating the depth buffer. Depth writing should normally be on but can 
be turned off when rendering static backgrounds or when rendering a 
collection of transparent objects at the end of a scene so that they 
overlap each other correctly.<br><br>

Default: depth_write on<br>

<a name="depth_func"></a>
<a name="SEC51"></a>
<h3> depth_func </h3>
<!--docid::SEC51::-->

Sets the function used to compare depth values when depth checking is on.<br><br>

Format: depth_func &lt;func&gt;<br><br>

If depth checking is enabled (see depth_check) a comparison occurs 
between the depth value of the pixel to be written and the current 
contents of the buffer. This comparison is normally less_equal, i.e. the
 pixel is written if it is closer (or at the same distance) than the 
current contents. The possible functions are:
<dl compact="compact">
<dt>always_fail
</dt><dd>Never writes a pixel to the render target
</dd><dt>always_pass
</dt><dd>Always writes a pixel to the render target
</dd><dt>less
</dt><dd>Write if (new_Z &lt; existing_Z)
</dd><dt>less_equal
</dt><dd>Write if (new_Z &lt;= existing_Z)
</dd><dt>equal
</dt><dd>Write if (new_Z == existing_Z)
</dd><dt>not_equal
</dt><dd>Write if (new_Z != existing_Z)
</dd><dt>greater_equal
</dt><dd>Write if (new_Z &gt;= existing_Z)
</dd><dt>greater
</dt><dd>Write if (new_Z &gt;existing_Z)
</dd></dl>
<br>
Default: depth_func less_equal

<a name="depth_bias"></a>
<a name="SEC52"></a>
<h3> depth_bias </h3>
<!--docid::SEC52::-->

Sets the bias applied to the depth value of this pass. Can be used to 
make coplanar polygons appear on top of others e.g. for decals. <br><br>

Format: depth_bias &lt;constant_bias&gt; [&lt;slopescale_bias&gt;]<br><br>

The final depth bias value is constant_bias * minObservableDepth + 
maxSlope * slopescale_bias. Slope scale biasing is relative to the angle
 of the polygon to the camera, which makes for a more appropriate bias 
value, but this is ignored on some older hardware. Constant biasing is 
expressed as a factor of the minimum depth value, so a value of 1 will 
nudge the depth by one 'notch' if you will. Also see <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC53">iteration_depth_bias</a><br><br>

<a name="iteration_depth_bias"></a>
<a name="SEC53"></a>
<h3> iteration_depth_bias </h3>
<!--docid::SEC53::-->

Sets an additional bias derived from the number of times a given pass has been iterated. Operates just like <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC52">depth_bias</a>
 except that it applies an additional bias factor to the base depth_bias
 value, multiplying the provided value by the number of times this pass 
has been iterated before, through one of the <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC71">iteration</a>
 variants. So the first time the pass will get the depth_bias value, the
 second time it will get depth_bias + iteration_depth_bias, the third 
time it will get depth_bias + iteration_depth_bias * 2, and so on. The 
default is zero. <br><br>

Format: iteration_depth_bias &lt;bias_per_iteration&gt;<br><br>

<br><br>

<a name="alpha_rejection"></a>
<a name="SEC54"></a>
<h3> alpha_rejection </h3>
<!--docid::SEC54::-->

Sets the way the pass will have use alpha to totally reject pixels from the pipeline.<br><br>

Format: alpha_rejection &lt;function&gt; &lt;value&gt;<br><br>

Example: alpha_rejection greater_equal 128<br><br>

The function parameter can be any of the options listed in the material 
depth_function attribute. The value parameter can theoretically be any 
value between 0 and 255, but is best limited to 0 or 128 for hardware 
compatibility.<br><br>

Default: alpha_rejection always_pass<br><br>

<a name="alpha_to_coverage"></a>
<a name="SEC55"></a>
<h3> alpha_to_coverage </h3>
<!--docid::SEC55::-->

Sets whether this pass will use 'alpha to coverage', a way to 
multisample alpha texture edges so they blend more seamlessly with the 
background. This facility is typically only available on cards from 
around 2006 onwards, but it is safe to enable it anyway - Ogre will just
 ignore it if the hardware does not support it. The common use for alpha
 to coverage is foliage rendering and chain-link fence style textures. <br><br>

Format: alpha_to_coverage &lt;on|off&gt;<br><br>

Default: alpha_to_coverage off<br><br>
<a name="light_scissor"></a>
<a name="SEC56"></a>
<h3> light_scissor </h3>
<!--docid::SEC56::-->

Sets whether when rendering this pass, rendering will be limited to a 
screen-space scissor rectangle representing the coverage of the light(s)
 being used in this pass, derived from their attenuation ranges.<br><br>

Format: light_scissor &lt;on|off&gt;<br><br>
Default: light_scissor off<br><br>

This option is usually only useful if this pass is an additive lighting 
pass, and is at least the second one in the technique. Ie areas which 
are not affected by the current light(s) will never need to be rendered.
 If there is more than one light being passed to the pass, then the 
scissor is defined to be the rectangle which covers all lights in 
screen-space. Directional lights are ignored since they are infinite.<br><br>

This option does not need to be specified if you are using a standard 
additive shadow mode, i.e. SHADOWTYPE_STENCIL_ADDITIVE or 
SHADOWTYPE_TEXTURE_ADDITIVE, since it is the default behaviour to use a 
scissor for each additive shadow pass. However, if you're not using 
shadows, or you're using <a href="http://www.ogre3d.org/docs/manual/manual_72.html#SEC337">Integrated Texture Shadows</a> where passes are specified in a custom manner, then this could be of use to you.

<a name="light_clip_planes"></a>
<a name="SEC57"></a>
<h3> light_clip_planes </h3>
<!--docid::SEC57::-->

Sets whether when rendering this pass, triangle setup will be limited to
 clipping volume covered by the light. Directional lights are ignored, 
point lights clip to a cube the size of the attenuation range or the 
light, and spotlights clip to a pyramid bounding the spotlight angle and
 attenuation range.<br><br>

Format: light_clip_planes &lt;on|off&gt;<br><br>
Default: light_clip_planes off<br><br>

This option will only function if there is a single non-directional 
light being used in this pass. If there is more than one light, or only 
directional lights, then no clipping will occur. If there are no lights 
at all then the objects won't be rendered at all.<br><br>

When using a standard additive shadow mode, ie 
SHADOWTYPE_STENCIL_ADDITIVE or SHADOWTYPE_TEXTURE_ADDITIVE, you have the
 option of enabling clipping for all light passes by calling 
SceneManager::setShadowUseLightClipPlanes regardless of this pass 
setting, since rendering is done lightwise anyway. This is off by 
default since using clip planes is not always faster - it depends on how
 much of the scene the light volumes cover. Generally the smaller your 
lights are the more chance you'll see a benefit rather than a penalty 
from clipping. If you're not using shadows, or you're using <a href="http://www.ogre3d.org/docs/manual/manual_72.html#SEC337">Integrated Texture Shadows</a> where passes are specified in a custom manner, then specify the option per-pass using this attribute.<br><br>
A specific note about OpenGL: user clip planes are completely ignored 
when you use an ARB vertex program. This means light clip planes won't 
help much if you use ARB vertex programs on GL, although OGRE will 
perform some optimisation of its own, in that if it sees that the clip 
volume is completely off-screen, it won't perform a render at all. When 
using GLSL, user clipping can be used but you have to use glClipVertex 
in your shader, see the GLSL documentation for more information. In 
Direct3D user clip planes are always respected.

<a name="illumination_stage"></a>
<a name="SEC58"></a>
<h3> illumination_stage </h3>
<!--docid::SEC58::-->

When using an additive lighting mode (SHADOWTYPE_STENCIL_ADDITIVE or 
SHADOWTYPE_TEXTURE_ADDITIVE), the scene is rendered in 3 discrete 
stages, ambient (or pre-lighting), per-light (once per light, with 
shadowing) and decal (or post-lighting). Usually OGRE figures out how to
 categorise your passes automatically, but there are some effects you 
cannot achieve without manually controlling the illumination. For 
example specular effects are muted by the typical sequence because all 
textures are saved until the 'decal' stage which mutes the specular 
effect. Instead, you could do texturing within the per-light stage if 
it's possible for your material and thus add the specular on after the 
decal texturing, and have no post-light rendering. <br><br>

If you assign an illumination stage to a pass you have to assign it to 
all passes in the technique otherwise it will be ignored. Also note that
 whilst you can have more than one pass in each group, they cannot 
alternate, ie all ambient passes will be before all per-light passes, 
which will also be before all decal passes. Within their categories the 
passes will retain their ordering though.

Format: illumination_stage &lt;ambient|per_light|decal&gt;<br><br>
Default: none (autodetect)<br><br>

<a name="normalise_normals"></a>
<a name="SEC59"></a>
<h3> normalise_normals </h3>
<!--docid::SEC59::-->

Sets whether or not this pass renders with all vertex normals being automatically re-normalised.<br>

Format: normalise_normals &lt;on|off&gt;<br><br>

Scaling objects causes normals to also change magnitude, which can throw
 off your lighting calculations. By default, the SceneManager detects 
this and will automatically re-normalise normals for any scaled object, 
but this has a cost. If you'd prefer to control this manually, call 
SceneManager::setNormaliseNormalsOnScale(false) and then use this option
 on materials which are sensitive to normals being resized. <br><br>

Default: normalise_normals off<br>

<a name="transparent_sorting"></a>
<a name="SEC60"></a>
<h3> transparent_sorting </h3>
<!--docid::SEC60::-->

Sets if transparent textures should be sorted by depth or not.<br><br>

Format: transparent_sorting &lt;on|off|force&gt;<br><br>

By default all transparent materials are sorted such that renderables 
furthest away from the camera are rendered first. This is usually the 
desired behaviour but in certain cases this depth sorting may be 
unnecessary and undesirable. If for example it is necessary to ensure 
the rendering order does not change from one frame to the next. In this 
case you could set the value to 'off' to prevent sorting.<br><br>

You can also use the keyword 'force' to force transparent sorting on, 
regardless of other circumstances. Usually sorting is only used when the
 pass is also transparent, and has a depth write or read which indicates
 it cannot reliably render without sorting. By using 'force', you tell 
OGRE to sort this pass no matter what other circumstances are present.<br><br>

Default: transparent_sorting on<br><br>

<a name="cull_hardware"></a>
<a name="SEC61"></a>
<h3> cull_hardware </h3>
<!--docid::SEC61::-->

Sets the hardware culling mode for this pass.<br><br>

Format: cull_hardware &lt;clockwise|anticlockwise|none&gt;<br><br>

A typical way for the hardware rendering engine to cull triangles is 
based on the 'vertex winding' of triangles. Vertex winding refers to the
 direction in which the vertices are passed or indexed to in the 
rendering operation as viewed from the camera, and will wither be 
clockwise or anticlockwise (that's 'counterclockwise' for you Americans 
out there ;). If the option 'cull_hardware clockwise' is set, all 
triangles whose vertices are viewed in clockwise order from the camera 
will be culled by the hardware. 'anticlockwise' is the reverse 
(obviously), and 'none' turns off hardware culling so all triagles are 
rendered (useful for creating 2-sided passes).<br><br>

Default: cull_hardware clockwise<br>
NB this is the same as OpenGL's default but the opposite of Direct3D's 
default (because Ogre uses a right-handed coordinate system like 
OpenGL).

<a name="cull_software"></a>
<a name="SEC62"></a>
<h3> cull_software </h3>
<!--docid::SEC62::-->

Sets the software culling mode for this pass.<br><br>

Format: cull_software &lt;back|front|none&gt;<br><br>

In some situations the engine will also cull geometry in software before
 sending it to the hardware renderer. This setting only takes effect on 
SceneManager's that use it (since it is best used on large groups of 
planar world geometry rather than on movable geometry since this would 
be expensive), but if used can cull geometry before it is sent to the 
hardware. In this case the culling is based on whether the 'back' or 
'front' of the triangle is facing the camera - this definition is based 
on the face normal (a vector which sticks out of the front side of the 
polygon perpendicular to the face). Since Ogre expects face normals to 
be on anticlockwise side of the face, 'cull_software back' is the 
software equivalent of 'cull_hardware clockwise' setting, which is why 
they are both the default. The naming is different to reflect the way 
the culling is done though, since most of the time face normals are 
pre-calculated and they don't have to be the way Ogre expects - you 
could set 'cull_hardware none' and completely cull in software based on 
your own face normals, if you have the right SceneManager which uses 
them.<br><br>

Default: cull_software back<br><br>

<a name="lighting"></a>
<a name="SEC63"></a>
<h3> lighting </h3>
<!--docid::SEC63::-->

Sets whether or not dynamic lighting is turned on for this pass or not. 
If lighting is turned off, all objects rendered using the pass will be 
fully lit. <strong>This attribute has no effect if a vertex program is used.</strong><br><br>

Format: lighting &lt;on|off&gt;<br><br>

Turning dynamic lighting off makes any ambient, diffuse, specular, 
emissive and shading properties for this pass redundant. When lighting 
is turned on, objects are lit according to their vertex normals for 
diffuse and specular light, and globally for ambient and emissive.<br><br>

Default: lighting on<br><br>

<a name="shading"></a>
<a name="SEC64"></a>
<h3> shading </h3>
<!--docid::SEC64::-->

Sets the kind of shading which should be used for representing dynamic lighting for this pass.<br><br>

Format: shading &lt;flat|gouraud|phong&gt;<br><br>

When dynamic lighting is turned on, the effect is to generate colour 
values at each vertex. Whether these values are interpolated across the 
face (and how) depends on this setting.<br><br>
<dl compact="compact">
<dt>flat
</dt><dd>	No interpolation takes place. Each face is shaded with a single colour determined from the first vertex in the face.
</dd><dt>gouraud
</dt><dd>	Colour at each vertex is linearly interpolated across the face.
</dd><dt>phong
</dt><dd>	Vertex normals are interpolated across the face, and these are
 used to determine colour at each pixel. Gives a more natural lighting 
effect but is more expensive and works better at high levels of 
tessellation. Not supported on all hardware.
</dd></dl>
Default: shading gouraud<br><br>

<a name="polygon_mode"></a>
<a name="SEC65"></a>
<h3> polygon_mode </h3>
<!--docid::SEC65::-->

Sets how polygons should be rasterised, i.e. whether they should be filled in, or just drawn as lines or points.<br><br>

Format: polygon_mode &lt;solid|wireframe|points&gt;<br><br>

<dl compact="compact">
<dt>solid
</dt><dd>The normal situation - polygons are filled in.
</dd><dt>wireframe
</dt><dd>Polygons are drawn in outline only.
</dd><dt>points
</dt><dd>Only the points of each polygon are rendered.
</dd></dl>
Default: polygon_mode solid<br><br>

<a name="polygon_mode_overrideable"></a>
<a name="SEC66"></a>
<h3> polygon_mode_overrideable </h3>
<!--docid::SEC66::-->

Sets whether or not the <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC65">polygon_mode</a>
 set on this pass can be downgraded by the camera, if the camera itself 
is set to a lower polygon mode. If set to false, this pass will always 
be rendered at its own chosen polygon mode no matter what the camera 
says. The default is true.<br><br>

Format: polygon_mode_overrideable &lt;true|false&gt;<br><br>

<a name="fog_override"></a>
<a name="SEC67"></a>
<h3> fog_override </h3>
<!--docid::SEC67::-->

Tells the pass whether it should override the scene fog settings, and 
enforce it's own. Very useful for things that you don't want to be 
affected by fog when the rest of the scene is fogged, or vice versa. 
Note that this only affects fixed-function fog - the original scene fog 
parameters are still sent to shaders which use the fog_params parameter 
binding (this allows you to turn off fixed function fog and calculate it
 in the shader instead; if you want to disable shader fog you can do 
that through shader parameters anyway). <br><br>

Format: fog_override &lt;override?&gt; [&lt;type&gt; &lt;colour&gt; &lt;density&gt; &lt;start&gt; &lt;end&gt;]<br><br>

Default: fog_override false<br><br>

If you specify 'true' for the first parameter and you supply the rest of
 the parameters, you are telling the pass to use these fog settings in 
preference to the scene settings, whatever they might be. If you specify
 'true' but provide no further parameters, you are telling this pass to 
never use fogging no matter what the scene says. Here is an explanation 
of the parameters:<br>
<dl compact="compact">
<dt>type
</dt><dd><strong>none</strong> = No fog, equivalent of just using 'fog_override true'<br>
<strong>linear</strong> = Linear fog from the &lt;start&gt; and &lt;end&gt; distances<br>
<strong>exp</strong> = Fog increases exponentially from the camera (fog = 1/e^(distance * density)), use &lt;density&gt; param to control it<br>
<strong>exp2</strong> = Fog increases at the square of FOG_EXP, i.e. 
even quicker (fog = 1/e^(distance * density)^2), use &lt;density&gt; 
param to control it
</dd><dt>colour
</dt><dd>	Sequence of 3 floating point values from 0 to 1 indicating the red, green and blue intensities
</dd><dt>density
</dt><dd>	The density parameter used in the 'exp' or 'exp2' fog types. 
Not used in linear mode but param must still be there as a placeholder
</dd><dt>start
</dt><dd>	The start distance from the camera of linear fog. Must still be present in other modes, even though it is not used.
</dd><dt>end
</dt><dd>	The end distance from the camera of linear fog. Must still be present in other modes, even though it is not used.
</dd></dl>
<br>
Example: fog_override true exp 1 1 1 0.002 100 10000

<a name="colour_write"></a>
<a name="SEC68"></a>
<h3> colour_write </h3>
<!--docid::SEC68::-->

Sets whether or not this pass renders with colour writing on or not.<br>

Format: colour_write &lt;on|off&gt;<br><br>

If colour writing is off no visible pixels are written to the screen 
during this pass. You might think this is useless, but if you render 
with colour writing off, and with very minimal other settings, you can 
use this pass to initialise the depth buffer before subsequently 
rendering other passes which fill in the colour data. This can give you 
significant performance boosts on some newer cards, especially when 
using complex fragment programs, because if the depth check fails then 
the fragment program is never run. <br><br>

Default: colour_write on<br>

<a name="start_light"></a>
<a name="SEC69"></a>
<h3> start_light </h3>
<!--docid::SEC69::-->

Sets the first light which will be considered for use with this pass.<br><br>
Format: start_light &lt;number&gt;<br><br>

You can use this attribute to offset the starting point of the lights 
for this pass. In other words, if you set start_light to 2 then the 
first light to be processed in that pass will be the third actual light 
in the applicable list. You could use this option to use different 
passes to process the first couple of lights versus the second couple of
 lights for example, or use it in conjunction with the <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC71">iteration</a>
 option to start the iteration from a given point in the list (e.g. 
doing the first 2 lights in the first pass, and then iterating every 2 
lights from then on perhaps). <br><br>

Default: start_light 0<br>

<a name="max_lights"></a>
<a name="SEC70"></a>
<h3> max_lights </h3>
<!--docid::SEC70::-->

Sets the maximum number of lights which will be considered for use with this pass.<br><br>
Format: max_lights &lt;number&gt;<br><br>

The maximum number of lights which can be used when rendering 
fixed-function materials is set by the rendering system, and is 
typically set at 8. When you are using the programmable pipeline (See 
section <a href="http://www.ogre3d.org/docs/manual/manual_23.html#SEC125">3.1.9 Using Vertex/Geometry/Fragment Programs in a Pass</a>) this limit is dependent on the program you are running, or, if you use 'iteration once_per_light' or a variant (See section <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC71">iteration</a>),
 it effectively only bounded by the number of passes you are willing to 
use. If you are not using pass iteration, the light limit applies once 
for this pass. If you are using pass iteration, the light limit applies 
across all iterations of this pass - for example if you have 12 lights 
in range with an 'iteration once_per_light' setup but your max_lights is
 set to 4 for that pass, the pass will only iterate 4 times. <br><br>

Default: max_lights 8<br>

<a name="iteration"></a>
<a name="SEC71"></a>
<h3> iteration </h3>
<!--docid::SEC71::-->

Sets whether or not this pass is iterated, i.e. issued more than once.<br><br>

Format 1: iteration &lt;once | once_per_light&gt; [lightType]<br><br>
Format 2: iteration &lt;number&gt; [&lt;per_light&gt; [lightType]]<br><br>
Format 3: iteration &lt;number&gt; [&lt;per_n_lights&gt; &lt;num_lights&gt; [lightType]]<br><br>
Examples:
<dl compact="compact">
<dt>iteration once
</dt><dd>	The pass is only executed once which is the default behaviour.
</dd><dt>iteration once_per_light point
</dt><dd>	The pass is executed once for each point light.
</dd><dt>iteration 5
</dt><dd>	The render state for the pass will be setup and then the draw call will execute 5 times.
</dd><dt>iteration 5 per_light point
</dt><dd>	The render state for the pass will be setup and then the draw 
call will execute 5 times.  This will be done for each point light.
</dd><dt>iteration 1 per_n_lights 2 point
</dt><dd>	The render state for the pass will be setup and the draw call executed once for every 2 lights.
</dd></dl>
<br>

By default, passes are only issued once. However, if you use the 
programmable pipeline, or you wish to exceed the normal limits on the 
number of lights which are supported, you might want to use the 
once_per_light option. In this case, only light index 0 is ever used, 
and the pass is issued multiple times, each time with a different light 
in light index 0. Clearly this will make the pass more expensive, but it
 may be the only way to achieve certain effects such as per-pixel 
lighting effects which take into account 1..n lights.<br><br>

Using a number instead of "once" instructs the pass to iterate more than
 once after the render state is setup.  The render state is not changed 
after the initial setup so repeated draw calls are very fast and ideal 
for passes using programmable shaders that must iterate more than once 
with the same render state i.e. shaders that do fur, motion blur, 
special filtering.<br><br>

If you use once_per_light, you should also add an ambient pass to the 
technique before this pass, otherwise when no lights are in range of 
this object it will not get rendered at all; this is important even when
 you have no ambient light in the scene, because you would still want 
the objects silhouette to appear.<br><br>

The lightType parameter to the attribute only applies if you use 
once_per_light, per_light, or per_n_lights and restricts the pass to 
being run for lights of a single type (either 'point', 'directional' or 
'spot'). In the example, the pass will be run once per point light. This
 can be useful because when you're writing a vertex / fragment program 
it is a lot easier if you can assume the kind of lights you'll be 
dealing with. However at least point and directional lights can be dealt
 with in one way.
<br><br>
Default: iteration once<br><br>

<a name="fur_example"></a>
Example: Simple Fur shader material script that uses a second pass with 10 iterations to grow the fur:
<table><tbody><tr><td>&nbsp;</td><td class="example"><pre>// GLSL simple Fur
vertex_program GLSLDemo/FurVS glsl 
{ 
  source fur.vert 
  default_params
  {
    param_named_auto lightPosition light_position_object_space 0
    param_named_auto eyePosition camera_position_object_space
    param_named_auto passNumber pass_number
    param_named_auto multiPassNumber pass_iteration_number
    param_named furLength float 0.15
  }
} 

fragment_program GLSLDemo/FurFS glsl 
{ 
  source fur.frag 
  default_params
  {
    param_named Ka float 0.2
    param_named Kd float 0.5
    param_named Ks float 0.0
    param_named furTU int 0
  }
} 

material Fur
{ 
  technique GLSL
  { 
    pass base_coat
    { 
      ambient 0.7 0.7 0.7
      diffuse 0.5 0.8 0.5
      specular 1.0 1.0 1.0 1.5

      vertex_program_ref GLSLDemo/FurVS
      {
      }

      fragment_program_ref GLSLDemo/FurFS 
      { 
      } 

      texture_unit
      {
        texture Fur.tga
        tex_coord_set 0
        filtering trilinear
      }

    } 

    pass grow_fur
    { 
      ambient 0.7 0.7 0.7
      diffuse 0.8 1.0 0.8
      specular 1.0 1.0 1.0 64
      depth_write off

      scene_blend src_alpha one
      iteration 10
      
      vertex_program_ref GLSLDemo/FurVS
      {
      }

      fragment_program_ref GLSLDemo/FurFS
      {
      }

      texture_unit
      {
        texture Fur.tga
        tex_coord_set 0
        filtering trilinear
      }
    } 
  } 
}
</pre></td></tr></tbody></table>Note: use gpu program auto parameters  <a href="http://www.ogre3d.org/docs/manual/manual_23.html#pass_number">pass_number</a> and  <a href="http://www.ogre3d.org/docs/manual/manual_23.html#pass_iteration_number">pass_iteration_number</a> to tell the vertex, geometry or fragment program the pass number and iteration number.<br><br>

<a name="point_size"></a>
<a name="SEC72"></a>
<h3> point_size </h3>
<!--docid::SEC72::-->

This setting allows you to change the size of points when rendering a 
point list, or a list of point sprites. The interpretation of this 
command depends on the <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC74">point_size_attenuation</a>
 option - if it is off (the default), the point size is in screen 
pixels, if it is on, it expressed as normalised screen coordinates (1.0 
is the height of the screen) when the point is at the origin.  <br><br>

NOTE: Some drivers have an upper limit on the size of points they 
support - this can even vary between APIs on the same card! Don't rely 
on point sizes that cause the points to get very large on screen, since 
they may get clamped on some cards. Upper sizes can range from 64 to 256
 pixels.<br><br>

Format: point_size &lt;size&gt;<br><br>
Default: point_size 1.0<br><br>

<a name="point_sprites"></a>
<a name="SEC73"></a>
<h3> point_sprites </h3>
<!--docid::SEC73::-->

This setting specifies whether or not hardware point sprite rendering is
 enabled for this pass. Enabling it means that a point list is rendered 
as a list of quads rather than a list of dots. It is very useful to use 
this option if you're using a BillboardSet and only need to use point 
oriented billboards which are all of the same size. You can also use it 
for any other point list render. <br><br>

Format: point_sprites &lt;on|off&gt;<br><br>
Default: point_sprites off<br><br>

<a name="point_size_attenuation"></a>
<a name="SEC74"></a>
<h3> point_size_attenuation </h3>
<!--docid::SEC74::-->

Defines whether point size is attenuated with view space distance, and 
in what fashion. This option is especially useful when you're using 
point sprites (See section <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC73">point_sprites</a>)
 since it defines how they reduce in size as they get further away from 
the camera. You can also disable this option to make point sprites a 
constant screen size (like points), or enable it for points so they 
change size with distance.<br><br>

You only have to provide the final 3 parameters if you turn attenuation 
on. The formula for attenuation is that the size of the point is 
multiplied by 1 / (constant + linear * dist + quadratic * d^2); 
therefore turning it off is equivalent to (constant = 1, linear = 0, 
quadratic = 0) and standard perspective attenuation is (constant = 0, 
linear = 1, quadratic = 0). The latter is assumed if you leave out the 
final 3 parameters when you specify 'on'.<br><br>

Note that the resulting attenuated size is clamped to the minimum and maximum point size, see the next section.<br><br>

Format: point_size_attenuation &lt;on|off&gt; [constant linear quadratic]
Default: point_size_attenuation off

<a name="point_size_min"></a>
<a name="SEC75"></a>
<h3> point_size_min </h3>
<!--docid::SEC75::-->

Sets the minimum point size after attenuation (<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC74">point_size_attenuation</a>). For details on the size metrics, See section <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC72">point_size</a>.<br><br>

Format: point_size_min &lt;size&gt;
Default: point_size_min 0

<a name="point_size_max"></a>
<a name="SEC76"></a>
<h3> point_size_max </h3>
<!--docid::SEC76::-->

Sets the maximum point size after attenuation (<a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC74">point_size_attenuation</a>). For details on the size metrics, See section <a href="http://www.ogre3d.org/docs/manual/manual_16.html#SEC72">point_size</a>. A value of 0 means the maximum is set to the same as the max size reported by the current card. <br><br>

Format: point_size_max &lt;size&gt;
Default: point_size_max 0

<a name="Texture Units"></a>
<hr size="1">
<table border="0" cellpadding="1" cellspacing="1">
<tbody><tr><td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_15.html#SEC33"> &lt; </a>]</td>
<td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_17.html#SEC77"> &gt; </a>]</td>
<td align="LEFT" valign="MIDDLE"> &nbsp; </td><td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_13.html#SEC22"> &lt;&lt; </a>]</td>
<td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_14.html#SEC23"> Up </a>]</td>
<td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_45.html#SEC268"> &gt;&gt; </a>]</td>
<td align="LEFT" valign="MIDDLE"> &nbsp; </td><td align="LEFT" valign="MIDDLE"> &nbsp; </td><td align="LEFT" valign="MIDDLE"> &nbsp; </td><td align="LEFT" valign="MIDDLE"> &nbsp; </td><td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/index.html#SEC_Top">Top</a>]</td>
<td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_toc.html#SEC_Contents">Contents</a>]</td>
<td align="LEFT" valign="MIDDLE">[Index]</td>
<td align="LEFT" valign="MIDDLE">[<a href="http://www.ogre3d.org/docs/manual/manual_abt.html#SEC_About"> ? </a>]</td>
</tr></tbody></table>
<br>
<font size="-1">
This document was generated
by <i>Steve Streeting</i> on <i>December, 31 2009</i>
using <a href="http://texi2html.cvshome.org/"><i>texi2html</i></a>
</font>



</body></html>