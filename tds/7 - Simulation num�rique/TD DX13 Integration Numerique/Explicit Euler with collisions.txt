// Pseudocode for explicit Euler integration for a collection of N particles with collisions

// Update the physics
void DoPhysicsSimulationStep(delta_t)
{
    // Detect collisions using methods described in
    // the Collision Detection and Resolution

    ...

    // Integrate the equations of motion to update
    // the physics.
    for (each object i NOT involved in a collision)
    {
        copy cur_S[2*i] and cur_S[2*i+1] to 
        prior_S[2*i] and prior_S[2*i+1]

        // Calculate the state derivative vector.
        S_derivs[2*i] = CalcForce(i);
        S_derivs[2*i+1] = prior_S[2*i] / mass[i];

        // Integrate equations of motion, for object i only.
        ExplicitEuler(2, &current_S[2*i],
                      &prior_S[2*i], &S_derivs[2*i], delta_t);
    }

    for (each pair of objects i, j, involved in a collision)
    {
        // tc is the time of the collision, which
        // occurs between t and t + delta_t.

        // Copy current state to prior state.
        copy cur_S[2*i] and cur_S[2*i+1] to 
        prior_S[2*i] and prior_S[2*i+1]

        copy cur_S[2*j] and cur_S[2*j+1] to 
        prior_S[2*j] and prior_S[2*j+1]

        // Calculate the state derivative vector.
        S_derivs[2*i] = CalcForce(i);
        S_derivs[2*i+1] = prior_S[2*i] / mass[i];

        S_derivs[2*j] = CalcForce(j);
        S_derivs[2*j+1] = prior_S[2*j] / mass[j];

        // First integration: prior to collision.
        ExplicitEuler(2, &cur_S[2*i], &prior_S[2*i],
                      &S_derivs[2*i], tc - t);

        ExplicitEuler(2, &cur_S[2*j], &prior_S[2*j],
                      &S_derivs[2*j], tc - t);

        // current_S now has the position and velocity of
        // objects i and j at tc, the time of collision.

        // Use Equations 13, 9, and 10 to compute the
        // after-collision linear momentums. The updated
        // momentums should be placed in cur_S[2*i] and
        // cur_S[2*j] for objects i and j, respectively.

        // Once cur_S reflects the after-collision
        // momentums, perform the after-collision
        // integration step, using the pseudo-code below.
	
        copy cur_S[2*i] and cur_S[2*i+1] to 
        prior_S[2*i] and prior_S[2*i+1]

        copy cur_S[2*j] and cur_S[2*j+1] to 
        prior_S[2*j] and prior_S[2*j+1]

        // Calculate the state derivative vector.
        S_derivs[2*i] = CalcForce(i);
        S_derivs[2*i+1] = prior_S[2*i] / mass[i];

        S_derivs[2*j] = CalcForce(j);
        S_derivs[2*j+1] = prior_S[2*j] / mass[j];
	
        // Second integration: after collision.
        ExplicitEuler(2, &cur_S[2*i], &prior_S[2*i], 
                      &S_derivs[2*i], t + delta_t - tc);

        ExplicitEuler(2, &cur_S[2*j], &prior_S[2*j], 
                      &S_derivs[2*j], t + delta_t - tc);
    }

    // Now all objects, including those in collision, have
    // been updated to time t + delta_t.

    // By integrating the equations of motion, we have
    // effectively moved simulation time forward by
    // delta_t.
    t = t + delta_t;
}
